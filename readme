Authorization: Bearer {TWÓJ_API_KEY}
User-Agent: {nazwa_sklepu} ({nazwa_modułu} v{wersja})
Accept: application/json
Content-Type: application/json
``` :contentReference[oaicite:0]{index=0}  

- Klucz API generujesz w panelu Erli:  
  `Metoda integracji → Własna integracja po API` :contentReference[oaicite:1]{index=1}  

- Przy przeciążeniu dostaniesz `429 Too Many Requests` – warto mieć retry / exponential backoff.

**Gdzie to w module**

- `classes/Api/ErlApiClient.php`
  - bazowy URL,
  - ustawienie nagłówków,
  - obsługę błędów (4xx/5xx),
  - logowanie do `ErliLog` (masz `Model/ErlLog.php` i `Repository/LogRepository.php`).

## 2. Wysyłanie produktów z PrestaShop → Erli

### 2.1. Jakie endpointy

- Tworzenie / aktualizacja produktu:
  - `POST /products/{externalId}` – pierwsze wysłanie produktu
  - `PATCH /products/{externalId}` – aktualizacja tylko zmienionych pól :contentReference[oaicite:2]{index=2}  

`externalId` to **ID produktu z Twojego sklepu** – dokładnie tak zaleca Erli. Jeśli masz kombinacje, Erli sugeruje „wzbogacenie” ID np. `123-red`, `123-blue-XL`. :contentReference[oaicite:3]{index=3}  

- Pobieranie listy produktów / pojedynczego – w referencji API są odpowiednie `GET /products` / `GET /products/{externalId}` (szczegóły w Swaggerze, link „Referencja API”).

### 2.2. Jakie dane musisz wysyłać (minimalne „core”)

Z dokumentacji wynika, że struktura produktu jest rozbudowana, ale na start praktyczna „podstawka” to: :contentReference[oaicite:4]{index=4}  

- `externalId` – ID z Presty (lub Presta product + attribute)
- `name` – nazwa z Presty
- `description` – opis (HTML lub struktura `sections/items`)
- `price` – cena brutto
- `vat` – stawka VAT
- `stock` – stan magazynowy
- `status` – `active` / `inactive`
- `images` – tablica URL-i zdjęć z Twojego sklepu
- `packaging.weight` – w gramach
- `packaging.tags` – identyfikator cennika dostawy (pierwszy element tablicy)
- `externalCategories` – drzewko kategorii ze sklepu (możesz wysłać swoje ID i nazwy)
- `externalAttributes` – cechy / atrybuty (kolor, rozmiar itd.)
- `externalVariantGroup` – jeśli masz warianty (kolor/rozmiar) – łączenie produktów w jedną „grupę wariantową”

**Opis** możesz wysłać jako czysty HTML w polu `description` – Erli i tak go skonwertuje do swojej struktury (ale przytnie do dozwolonych tagów). :contentReference[oaicite:5]{index=5}  

**Obrazki** – oczekują dużych zdjęć (do 5120x5120, WebP/PNG/JPEG) pod URL-ami z Twojego sklepu. Pamiętaj, że Erli *cache’uje* URL – jeśli podmienisz plik bez zmiany ścieżki, oni go nie pobiorą ponownie; warto doklejać np. hash do URL. :contentReference[oaicite:6]{index=6}  

### 2.3. Sugerowany flow synchronizacji produktów 

- Trzymaj w swojej tabeli (np. `erli_product_link`) zrzut danych, które wysłałeś.
- Przy aktualizacji:
  1. Mappujesz produkt Presty → struktura Erli (`Mapper/ProductMapper.php`).
  2. Porównujesz z tym, co masz zapisane w `ErlProductLink` / `ProductLinkRepository`.
  3. Wysyłasz **tylko różnice** metodą `PATCH`.
  4. Po sukcesie aktualizujesz swój rekord. :contentReference[oaicite:7]{index=7}  


- `Mapper/ProductMapper.php` – Presta product → tablica dla API
- `Api/ErlProductApi.php` – metody `createProduct`, `updateProduct`, `getProduct`
- `Model/ErlProductLink.php` + `Repository/ProductLinkRepository.php` – cache wysłanych danych
- `Sync/ProductSync.php` – logika „przeleć po produktach i zsynchronizuj” (wywoływane z CRON-a / przycisku w panelu)
---
## 3. Pobieranie zamówień z Erli → PrestaShop

Dwa sposoby: :contentReference[oaicite:8]{index=8}  

1. **Inbox** – eventy (rekomendowane).
2. **Klasyczna lista zamówień** – `GET /orders` z paginacją + filtr po dacie.

### 3.1. Inbox – eventy

- Endpoint: `GET /inbox` zwraca zdarzenia:
  - nowe zamówienia / zmiany zamówień,
  - info że produkty wymagają synchronizacji (`productsNeedSync`),
  - w przyszłości również inne typy zdarzeń. :contentReference[oaicite:9]{index=9}  

- Za jednym razem pobierasz maksymalnie 500 **nieprzeczytanych** wiadomości – po przetworzeniu *musisz* oznaczyć je jako przeczytane, podając ID ostatniej wiadomości (konkretny endpoint jest w referencji, ale mechanizm jest właśnie taki). :contentReference[oaicite:10]{index=10}  

**Hooki** (webhooki):
- Możesz zarejestrować hooka `orderCreated` / `orderStatusChanged` przez `POST /hooks`.
- Erli wtedy *samo* wywoła Twój URL, np.:

```json
{
  "id": "1234x5678",
  "status": "pending"
}
``` :contentReference[oaicite:11]{index=11}  

- Pełna struktura zamówienia jest opisana w swaggerze pod `#/inbox/get_inbox`.

**Jak to pożenić z Prestą**

- W Preście można jako „odbiornik hooka” wystawić kontroler frontowy:  
  `controllers/front/CronModuleFrontController.php` albo osobny `HookOrderCreatedModuleFrontController.php`, który:
  - odbiera POST od Erli,
  - zapisuje ID zamówienia Erli do jakiegoś bufora (tabela `erli_order_link` / `ErliOrderLink`),
  - ewentualnie od razu woła `ErlOrderApi->getOrder($id)` i tworzy zamówienie w Preście.

- Dodatkowo Cron (`CronModuleFrontController.php`) może co parę minut:
  - przewinąć `GET /inbox`,
  - przetworzyć nowe eventy,
  - oznaczyć inbox jako przeczytany.

### 3.2. Klasyczne pobieranie zamówień

Dokumentacja sugeruje też „zwykłe” pobieranie listy zamówień z paginacją, sortowane po dacie utworzenia / aktualizacji, z filtrem `pagination.after`. :contentReference[oaicite:12]{index=12}  

- W body wysyłasz coś w stylu:

```json
{
  "pagination": {
    "sortField": "created",
    "after": "2024-01-01",
    "limit": 50
  }
}




